#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#include"team.h"
#include"hash.h"
int hash(char*key,int size){int sumOfKey=0,count=-1,index=-1;int length=strlen(key);for(count=0;count<length;count++){if(key[count]!='a'&&key[count]!='e'&&key[count]!='i'&&key[count]!='o'&&key[count]!='u'&&key[count]!='A'&&key[count]!='E'&&key[count]!='I'&&key[count]!='O'&&key[count]!='U'){sumOfKey=key[count]+(sumOfKey % size);}}index=sumOfKey % size;return index;}int collision(char*key,int index,int size){int sumOfKey=0,count=-1,newIndex=-1,length=strlen(key);for(count=0;count<length;count++)sumOfKey+=*(key+count);newIndex=index+(sumOfKey / size);while(newIndex>(size - 1))newIndex %=size;return newIndex;}void updateCollision(DATA_HEAD*dataNode){int count=-1,count2=-1,index=-1;int updateCount=-1;for(count=0;count<dataNode->arraySize;count++){if(dataNode->pHash[count].numOfCollisions>0){updateCount=0;index=hash(dataNode->pHash[count].hashData->companyName,dataNode->arraySize);if(dataNode->pHash[index].status==1){if(strcasecmp(dataNode->pHash[count].hashData->companyName,dataNode->pHash[index].hashData->companyName)==0)break;else updateCount++;}for(count2=1;count2<dataNode->pHash[count].numOfProbes;count2++){index=collision(dataNode->pHash[count].hashData->companyName,index,dataNode->arraySize);if(dataNode->pHash[index].status==1){if(strcasecmp(dataNode->pHash[count].hashData->companyName,dataNode->pHash[index].hashData->companyName)==0)break;else updateCount++;}}dataNode->pHash[count].numOfCollisions=updateCount;}}}int insertHash(DATA_HEAD*dataNode,COMPANY*dataInsert){int index=-1,tempStatus=-1;int collisionCount=0;int probe=0;index=hash(dataInsert->companyName,dataNode->arraySize);probe++;if(dataNode->pHash[index].status==0||dataNode->pHash[index].status==2){tempStatus=dataNode->pHash[index].status;dataNode->pHash[index].hashData=dataInsert;dataNode->pHash[index].status=1;dataNode->pHash[index].numOfProbes=probe;if(tempStatus==2)updateCollision(dataNode);}else{while(dataNode->pHash[index].status==1&&probe<MAX_PROBE){collisionCount++;index=collision(dataInsert->companyName,index,dataNode->arraySize);probe++;}if(dataNode->pHash[index].status==0||dataNode->pHash[index].status==2){tempStatus=dataNode->pHash[index].status;dataNode->pHash[index].hashData=dataInsert;dataNode->pHash[index].status=1;dataNode->pHash[index].numOfCollisions=collisionCount;dataNode->pHash[index].numOfProbes=probe;if(tempStatus==2)updateCollision(dataNode);}else{return 0;}}return 1;}int deleteHash(DATA_HEAD*dataNode,char*key){int index=-1,probe=0;index=hash(key,dataNode->arraySize);probe++;if(dataNode->pHash[index].status==0)return 0;if(dataNode->pHash[index].status==1&&strcasecmp(dataNode->pHash[index].hashData->companyName,key)==0){dataNode->pHash[index].hashData=NULL;dataNode->pHash[index].status=2;dataNode->pHash[index].numOfCollisions=0;dataNode->pHash[index].numOfProbes=0;updateCollision(dataNode);}else{while(dataNode->pHash[index].status!=0||(dataNode->pHash[index].status==2&&probe<MAX_PROBE)){index=collision(key,index,dataNode->arraySize);probe++;if(dataNode->pHash[index].status==1&&strcasecmp(dataNode->pHash[index].hashData->companyName,key)==0){dataNode->pHash[index].hashData=NULL;dataNode->pHash[index].status=2;dataNode->pHash[index].numOfCollisions=0;dataNode->pHash[index].numOfProbes=0;updateCollision(dataNode);break;}if(dataNode->pHash[index].status==0||probe==(MAX_PROBE -1)){return 0;}}}return 1;}int searchHash(DATA_HEAD*dataNode,char*key,COMPANY*returnData){int index=-1,probe=0;index=hash(key,dataNode->arraySize);probe++;if(dataNode->pHash[index].status==0)return 0;if(dataNode->pHash[index].status==1&&strcasecmp(dataNode->pHash[index].hashData->companyName,key)==0){*returnData=*(dataNode->pHash[index].hashData);}else{while(dataNode->pHash[index].status!=0||(dataNode->pHash[index].status==2&&probe<MAX_PROBE)){index=collision(key,index,dataNode->arraySize);probe++;if(dataNode->pHash[index].status==1&&strcasecmp(dataNode->pHash[index].hashData->companyName,key)==0){*returnData=*(dataNode->pHash[index].hashData);break;}if(dataNode->pHash[index].status==0||probe==(MAX_PROBE -1)){return 0;}}}return 1;}void printEfficiency(DATA_HEAD*dataNode){int count=-1,count2=-1,index=-1;int collisionIndex=-1;double loadFactor=-1;int numOfCollisions=0;int numOfElements=0;int longestCollision=0;int multiple=-1;for(count=0;count<dataNode->arraySize;count++){if(dataNode->pHash[count].status==1)numOfElements++;if(dataNode->pHash[count].numOfCollisions>0){numOfCollisions++;if(dataNode->pHash[count].numOfCollisions>longestCollision||dataNode->pHash[count].numOfCollisions==longestCollision){if(dataNode->pHash[count].numOfCollisions>longestCollision){longestCollision=dataNode->pHash[count].numOfCollisions;collisionIndex=count;multiple=-1;}else{multiple=1;}}}}loadFactor=((double)numOfElements /(double)dataNode->arraySize)*100;printf("****************EFFICIENCY:****************\n\n");printf("Load factor:%.2f%%\n",loadFactor);printf("Number of data records with collision:%d\n",numOfCollisions);printf("Longest collision path:%d\n",longestCollision);printf("Output longest collision path(s):\n");if(multiple==-1){printf("\n\nKEY:%s\n\n",dataNode->pHash[collisionIndex].hashData->companyName);printf("(Home Address)=>");index=hash(dataNode->pHash[collisionIndex].hashData->companyName,dataNode->arraySize);if(dataNode->pHash[index].status==1)printf("[%2d]%s",index,dataNode->pHash[index].hashData->companyName);else printf("<DELETED>");printf("\n(Overflow Area)=>");for(count=1;count<dataNode->pHash[collisionIndex].numOfProbes;count++){index=collision(dataNode->pHash[collisionIndex].hashData->companyName,index,dataNode->arraySize);if(dataNode->pHash[index].status==1)printf("[%2d]%s",index,dataNode->pHash[index].hashData->companyName);else printf("<DELETED>");if(count+1<dataNode->pHash[collisionIndex].numOfProbes)printf("\n\t\t=>");}printf("\n");}else{for(count=0;count<dataNode->arraySize;count++){if(dataNode->pHash[count].numOfCollisions==longestCollision){printf("\n\nKEY:%s\n\n",dataNode->pHash[count].hashData->companyName);printf("(Home Address)=>");index=hash(dataNode->pHash[count].hashData->companyName,dataNode->arraySize);if(dataNode->pHash[index].status==1)printf("[%2d]%s",index,dataNode->pHash[index].hashData->companyName);else printf("<DELETED>");printf("\n(Overflow Area)=>");for(count2=1;count2<dataNode->pHash[count].numOfProbes;count2++){index=collision(dataNode->pHash[count].hashData->companyName,index,dataNode->arraySize);if(dataNode->pHash[index].status==1)printf("[%2d]%s",index,dataNode->pHash[index].hashData->companyName);else printf("<DELETED>");if(count2+1<dataNode->pHash[count].numOfProbes)printf("\n\t\t=>");}printf("\n");}}}printf("\n*********************************************\n\n");}
