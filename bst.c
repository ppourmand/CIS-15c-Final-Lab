#include<stdlib.h>
#include"bst.h"
BST*createBST(int(*compare)(void*a,void*b)){BST*bst=NULL;bst=(BST*)malloc(sizeof(BST));if(bst){bst->root=NULL;bst->count=0;bst->compare=compare;}return bst;}int insertBST(BST*bst,void*dataInPtr){BST_NODE*newPtr;int dupcheck=1;newPtr=(BST_NODE*)malloc(sizeof(BST_NODE));if(!newPtr)return 0;newPtr->dataPtr=dataInPtr;newPtr->left=NULL;newPtr->right=NULL;if(bst->count==0)bst->root=newPtr;else _insert(bst,bst->root,newPtr,&dupcheck);if(dupcheck!=1)return-1;(bst->count)++;return 1;}BST_NODE*_insert(BST*bst,BST_NODE*root,BST_NODE*newPtr,int*dupcheck){if(!root)return newPtr;if(bst->compare(newPtr->dataPtr,root->dataPtr)<0){root->left=_insert(bst,root->left,newPtr,dupcheck);}else if(bst->compare(newPtr->dataPtr,root->dataPtr)>0){root->right=_insert(bst,root->right,newPtr,dupcheck);}else{*dupcheck=0;}return root;}int deleteBST(BST*bst,void*dltKey,void**retptr){int success;BST_NODE*newRoot;newRoot=_delete(bst,bst->root,dltKey,&success,retptr);if(success){bst->root=newRoot;(bst->count)--;if(bst->count==0)bst->root=NULL;}return success;}BST_NODE*_delete(BST*bst,BST_NODE*root,void*dltKey,int*success,void**retptr){BST_NODE*dltPtr;BST_NODE*exchPtr;BST_NODE*newRoot;BST_NODE*holdPtr;if(!root){*success=0;return NULL;}if(bst->compare(dltKey,root->dataPtr)<0)root->left=_delete(bst,root->left,dltKey,success,retptr);else if(bst->compare(dltKey,root->dataPtr)>0)root->right=_delete(bst,root->right,dltKey,success,retptr);else{dltPtr=root;if(!root->left){*retptr=root->dataPtr;newRoot=root->right;free(dltPtr);*success=1;return newRoot;}else{if(!root->right){*retptr=root->dataPtr;newRoot=root->left;free(dltPtr);*success=1;return newRoot;}else{exchPtr=root->left;while(exchPtr->right)exchPtr=exchPtr->right;holdPtr=root->dataPtr;root->dataPtr=exchPtr->dataPtr;exchPtr->dataPtr=holdPtr;root->left=_delete(bst,root->left,exchPtr->dataPtr,success,retptr);}}}return root;}void*retrieveBST(BST*bst,void*keyPtr){if(bst->root)return _retrieve(bst,keyPtr,bst->root);else return NULL;}void*_retrieve(BST*bst,void*keyPtr,BST_NODE*root){if(!root)return NULL;else if(bst->compare(keyPtr,root->dataPtr)<0)return _retrieve(bst,keyPtr,root->left);else if(bst->compare(keyPtr,root->dataPtr)>0)return _retrieve(bst,keyPtr,root->right);else return root->dataPtr;}void inOrder(BST*bst,void(*process)(void*dataPtr)){_traverse(bst->root,process);return;}void _traverse(BST_NODE*root,void(*process)(void*dataPtr)){if(root){_traverse(root->left,process);process(root->dataPtr);_traverse(root->right,process);}return;}void inRankOrder(BST*bst,void(*process)(void*dataPtr,int level)){_rank(bst->root,process,0);return;}void _rank(BST_NODE*root,void(*process)(void*dataPtr,int level),int level){if(root){level++;_rank(root->right,process,level);process(root->dataPtr,level);_rank(root->left,process,level);}return;}int emptyBST(BST*bst){return(bst->count==0);}int fullBST(BST*bst){BST_NODE*temp;if((temp=(BST_NODE*)malloc(sizeof(BST_NODE)))){free(temp);return 0;}return 1;}int BSTCount(BST*bst){return bst->count;}BST*destroyBST(BST*bst,void(*freeFcn)(void*dataPtr)){if(bst)_destroy(bst->root,freeFcn);free(bst);return NULL;}void _destroy(BST_NODE*root,void(*freeFcn)(void*dataPtr)){if(root){_destroy(root->left,freeFcn);freeFcn(root->dataPtr);_destroy(root->right,freeFcn);free(root);}return;}
